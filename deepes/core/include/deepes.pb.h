// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deepes.proto

#ifndef PROTOBUF_deepes_2eproto__INCLUDED
#define PROTOBUF_deepes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace DeepES {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_deepes_2eproto();
void protobuf_AssignDesc_deepes_2eproto();
void protobuf_ShutdownFile_deepes_2eproto();

class DeepESConfig;
class GaussianSamplingConfig;
class OptimizerConfig;
class SamplingInfo;
class AsyncESConfig;

// ===================================================================

class DeepESConfig : public ::google::protobuf::Message {
 public:
  DeepESConfig();
  virtual ~DeepESConfig();
  
  DeepESConfig(const DeepESConfig& from);
  
  inline DeepESConfig& operator=(const DeepESConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeepESConfig& default_instance();
  
  void Swap(DeepESConfig* other);
  
  // implements Message ----------------------------------------------
  
  DeepESConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeepESConfig& from);
  void MergeFrom(const DeepESConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 seed = 1 [default = 18];
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 1;
  inline ::google::protobuf::int32 seed() const;
  inline void set_seed(::google::protobuf::int32 value);
  
  // optional int32 buffer_size = 2 [default = 100000];
  inline bool has_buffer_size() const;
  inline void clear_buffer_size();
  static const int kBufferSizeFieldNumber = 2;
  inline ::google::protobuf::int32 buffer_size() const;
  inline void set_buffer_size(::google::protobuf::int32 value);
  
  // optional .DeepES.GaussianSamplingConfig gaussian_sampling = 3;
  inline bool has_gaussian_sampling() const;
  inline void clear_gaussian_sampling();
  static const int kGaussianSamplingFieldNumber = 3;
  inline const ::DeepES::GaussianSamplingConfig& gaussian_sampling() const;
  inline ::DeepES::GaussianSamplingConfig* mutable_gaussian_sampling();
  inline ::DeepES::GaussianSamplingConfig* release_gaussian_sampling();
  
  // optional .DeepES.OptimizerConfig optimizer = 4;
  inline bool has_optimizer() const;
  inline void clear_optimizer();
  static const int kOptimizerFieldNumber = 4;
  inline const ::DeepES::OptimizerConfig& optimizer() const;
  inline ::DeepES::OptimizerConfig* mutable_optimizer();
  inline ::DeepES::OptimizerConfig* release_optimizer();
  
  // optional .DeepES.AsyncESConfig async_es = 5;
  inline bool has_async_es() const;
  inline void clear_async_es();
  static const int kAsyncEsFieldNumber = 5;
  inline const ::DeepES::AsyncESConfig& async_es() const;
  inline ::DeepES::AsyncESConfig* mutable_async_es();
  inline ::DeepES::AsyncESConfig* release_async_es();
  
  // @@protoc_insertion_point(class_scope:DeepES.DeepESConfig)
 private:
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_buffer_size();
  inline void clear_has_buffer_size();
  inline void set_has_gaussian_sampling();
  inline void clear_has_gaussian_sampling();
  inline void set_has_optimizer();
  inline void clear_has_optimizer();
  inline void set_has_async_es();
  inline void clear_has_async_es();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 seed_;
  ::google::protobuf::int32 buffer_size_;
  ::DeepES::GaussianSamplingConfig* gaussian_sampling_;
  ::DeepES::OptimizerConfig* optimizer_;
  ::DeepES::AsyncESConfig* async_es_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_deepes_2eproto();
  friend void protobuf_AssignDesc_deepes_2eproto();
  friend void protobuf_ShutdownFile_deepes_2eproto();
  
  void InitAsDefaultInstance();
  static DeepESConfig* default_instance_;
};
// -------------------------------------------------------------------

class GaussianSamplingConfig : public ::google::protobuf::Message {
 public:
  GaussianSamplingConfig();
  virtual ~GaussianSamplingConfig();
  
  GaussianSamplingConfig(const GaussianSamplingConfig& from);
  
  inline GaussianSamplingConfig& operator=(const GaussianSamplingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GaussianSamplingConfig& default_instance();
  
  void Swap(GaussianSamplingConfig* other);
  
  // implements Message ----------------------------------------------
  
  GaussianSamplingConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GaussianSamplingConfig& from);
  void MergeFrom(const GaussianSamplingConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float std = 1 [default = 1];
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 1;
  inline float std() const;
  inline void set_std(float value);
  
  // @@protoc_insertion_point(class_scope:DeepES.GaussianSamplingConfig)
 private:
  inline void set_has_std();
  inline void clear_has_std();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float std_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_deepes_2eproto();
  friend void protobuf_AssignDesc_deepes_2eproto();
  friend void protobuf_ShutdownFile_deepes_2eproto();
  
  void InitAsDefaultInstance();
  static GaussianSamplingConfig* default_instance_;
};
// -------------------------------------------------------------------

class OptimizerConfig : public ::google::protobuf::Message {
 public:
  OptimizerConfig();
  virtual ~OptimizerConfig();
  
  OptimizerConfig(const OptimizerConfig& from);
  
  inline OptimizerConfig& operator=(const OptimizerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OptimizerConfig& default_instance();
  
  void Swap(OptimizerConfig* other);
  
  // implements Message ----------------------------------------------
  
  OptimizerConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OptimizerConfig& from);
  void MergeFrom(const OptimizerConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string type = 1 [default = "SGD"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // optional float base_lr = 2 [default = 0.001];
  inline bool has_base_lr() const;
  inline void clear_base_lr();
  static const int kBaseLrFieldNumber = 2;
  inline float base_lr() const;
  inline void set_base_lr(float value);
  
  // optional float momentum = 3 [default = 0.9];
  inline bool has_momentum() const;
  inline void clear_momentum();
  static const int kMomentumFieldNumber = 3;
  inline float momentum() const;
  inline void set_momentum(float value);
  
  // optional float beta1 = 4 [default = 0.9];
  inline bool has_beta1() const;
  inline void clear_beta1();
  static const int kBeta1FieldNumber = 4;
  inline float beta1() const;
  inline void set_beta1(float value);
  
  // optional float beta2 = 5 [default = 0.999];
  inline bool has_beta2() const;
  inline void clear_beta2();
  static const int kBeta2FieldNumber = 5;
  inline float beta2() const;
  inline void set_beta2(float value);
  
  // optional float epsilon = 6 [default = 1e-08];
  inline bool has_epsilon() const;
  inline void clear_epsilon();
  static const int kEpsilonFieldNumber = 6;
  inline float epsilon() const;
  inline void set_epsilon(float value);
  
  // @@protoc_insertion_point(class_scope:DeepES.OptimizerConfig)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_base_lr();
  inline void clear_has_base_lr();
  inline void set_has_momentum();
  inline void clear_has_momentum();
  inline void set_has_beta1();
  inline void clear_has_beta1();
  inline void set_has_beta2();
  inline void clear_has_beta2();
  inline void set_has_epsilon();
  inline void clear_has_epsilon();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* type_;
  static const ::std::string _default_type_;
  float base_lr_;
  float momentum_;
  float beta1_;
  float beta2_;
  float epsilon_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_deepes_2eproto();
  friend void protobuf_AssignDesc_deepes_2eproto();
  friend void protobuf_ShutdownFile_deepes_2eproto();
  
  void InitAsDefaultInstance();
  static OptimizerConfig* default_instance_;
};
// -------------------------------------------------------------------

class SamplingInfo : public ::google::protobuf::Message {
 public:
  SamplingInfo();
  virtual ~SamplingInfo();
  
  SamplingInfo(const SamplingInfo& from);
  
  inline SamplingInfo& operator=(const SamplingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SamplingInfo& default_instance();
  
  void Swap(SamplingInfo* other);
  
  // implements Message ----------------------------------------------
  
  SamplingInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SamplingInfo& from);
  void MergeFrom(const SamplingInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 key = 1;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::int32 key(int index) const;
  inline void set_key(int index, ::google::protobuf::int32 value);
  inline void add_key(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      key() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_key();
  
  // optional int32 model_iter_id = 2;
  inline bool has_model_iter_id() const;
  inline void clear_model_iter_id();
  static const int kModelIterIdFieldNumber = 2;
  inline ::google::protobuf::int32 model_iter_id() const;
  inline void set_model_iter_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:DeepES.SamplingInfo)
 private:
  inline void set_has_model_iter_id();
  inline void clear_has_model_iter_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > key_;
  ::google::protobuf::int32 model_iter_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_deepes_2eproto();
  friend void protobuf_AssignDesc_deepes_2eproto();
  friend void protobuf_ShutdownFile_deepes_2eproto();
  
  void InitAsDefaultInstance();
  static SamplingInfo* default_instance_;
};
// -------------------------------------------------------------------

class AsyncESConfig : public ::google::protobuf::Message {
 public:
  AsyncESConfig();
  virtual ~AsyncESConfig();
  
  AsyncESConfig(const AsyncESConfig& from);
  
  inline AsyncESConfig& operator=(const AsyncESConfig& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AsyncESConfig& default_instance();
  
  void Swap(AsyncESConfig* other);
  
  // implements Message ----------------------------------------------
  
  AsyncESConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AsyncESConfig& from);
  void MergeFrom(const AsyncESConfig& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string model_warehouse = 1 [default = "./model_warehouse"];
  inline bool has_model_warehouse() const;
  inline void clear_model_warehouse();
  static const int kModelWarehouseFieldNumber = 1;
  inline const ::std::string& model_warehouse() const;
  inline void set_model_warehouse(const ::std::string& value);
  inline void set_model_warehouse(const char* value);
  inline void set_model_warehouse(const char* value, size_t size);
  inline ::std::string* mutable_model_warehouse();
  inline ::std::string* release_model_warehouse();
  
  // repeated string model_md5 = 2;
  inline int model_md5_size() const;
  inline void clear_model_md5();
  static const int kModelMd5FieldNumber = 2;
  inline const ::std::string& model_md5(int index) const;
  inline ::std::string* mutable_model_md5(int index);
  inline void set_model_md5(int index, const ::std::string& value);
  inline void set_model_md5(int index, const char* value);
  inline void set_model_md5(int index, const char* value, size_t size);
  inline ::std::string* add_model_md5();
  inline void add_model_md5(const ::std::string& value);
  inline void add_model_md5(const char* value);
  inline void add_model_md5(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& model_md5() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_model_md5();
  
  // optional int32 max_to_keep = 3 [default = 5];
  inline bool has_max_to_keep() const;
  inline void clear_max_to_keep();
  static const int kMaxToKeepFieldNumber = 3;
  inline ::google::protobuf::int32 max_to_keep() const;
  inline void set_max_to_keep(::google::protobuf::int32 value);
  
  // optional int32 model_iter_id = 4 [default = 0];
  inline bool has_model_iter_id() const;
  inline void clear_model_iter_id();
  static const int kModelIterIdFieldNumber = 4;
  inline ::google::protobuf::int32 model_iter_id() const;
  inline void set_model_iter_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:DeepES.AsyncESConfig)
 private:
  inline void set_has_model_warehouse();
  inline void clear_has_model_warehouse();
  inline void set_has_max_to_keep();
  inline void clear_has_max_to_keep();
  inline void set_has_model_iter_id();
  inline void clear_has_model_iter_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* model_warehouse_;
  static const ::std::string _default_model_warehouse_;
  ::google::protobuf::RepeatedPtrField< ::std::string> model_md5_;
  ::google::protobuf::int32 max_to_keep_;
  ::google::protobuf::int32 model_iter_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_deepes_2eproto();
  friend void protobuf_AssignDesc_deepes_2eproto();
  friend void protobuf_ShutdownFile_deepes_2eproto();
  
  void InitAsDefaultInstance();
  static AsyncESConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// DeepESConfig

// optional int32 seed = 1 [default = 18];
inline bool DeepESConfig::has_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeepESConfig::set_has_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeepESConfig::clear_has_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeepESConfig::clear_seed() {
  seed_ = 18;
  clear_has_seed();
}
inline ::google::protobuf::int32 DeepESConfig::seed() const {
  return seed_;
}
inline void DeepESConfig::set_seed(::google::protobuf::int32 value) {
  set_has_seed();
  seed_ = value;
}

// optional int32 buffer_size = 2 [default = 100000];
inline bool DeepESConfig::has_buffer_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeepESConfig::set_has_buffer_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeepESConfig::clear_has_buffer_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeepESConfig::clear_buffer_size() {
  buffer_size_ = 100000;
  clear_has_buffer_size();
}
inline ::google::protobuf::int32 DeepESConfig::buffer_size() const {
  return buffer_size_;
}
inline void DeepESConfig::set_buffer_size(::google::protobuf::int32 value) {
  set_has_buffer_size();
  buffer_size_ = value;
}

// optional .DeepES.GaussianSamplingConfig gaussian_sampling = 3;
inline bool DeepESConfig::has_gaussian_sampling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeepESConfig::set_has_gaussian_sampling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeepESConfig::clear_has_gaussian_sampling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeepESConfig::clear_gaussian_sampling() {
  if (gaussian_sampling_ != NULL) gaussian_sampling_->::DeepES::GaussianSamplingConfig::Clear();
  clear_has_gaussian_sampling();
}
inline const ::DeepES::GaussianSamplingConfig& DeepESConfig::gaussian_sampling() const {
  return gaussian_sampling_ != NULL ? *gaussian_sampling_ : *default_instance_->gaussian_sampling_;
}
inline ::DeepES::GaussianSamplingConfig* DeepESConfig::mutable_gaussian_sampling() {
  set_has_gaussian_sampling();
  if (gaussian_sampling_ == NULL) gaussian_sampling_ = new ::DeepES::GaussianSamplingConfig;
  return gaussian_sampling_;
}
inline ::DeepES::GaussianSamplingConfig* DeepESConfig::release_gaussian_sampling() {
  clear_has_gaussian_sampling();
  ::DeepES::GaussianSamplingConfig* temp = gaussian_sampling_;
  gaussian_sampling_ = NULL;
  return temp;
}

// optional .DeepES.OptimizerConfig optimizer = 4;
inline bool DeepESConfig::has_optimizer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeepESConfig::set_has_optimizer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeepESConfig::clear_has_optimizer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeepESConfig::clear_optimizer() {
  if (optimizer_ != NULL) optimizer_->::DeepES::OptimizerConfig::Clear();
  clear_has_optimizer();
}
inline const ::DeepES::OptimizerConfig& DeepESConfig::optimizer() const {
  return optimizer_ != NULL ? *optimizer_ : *default_instance_->optimizer_;
}
inline ::DeepES::OptimizerConfig* DeepESConfig::mutable_optimizer() {
  set_has_optimizer();
  if (optimizer_ == NULL) optimizer_ = new ::DeepES::OptimizerConfig;
  return optimizer_;
}
inline ::DeepES::OptimizerConfig* DeepESConfig::release_optimizer() {
  clear_has_optimizer();
  ::DeepES::OptimizerConfig* temp = optimizer_;
  optimizer_ = NULL;
  return temp;
}

// optional .DeepES.AsyncESConfig async_es = 5;
inline bool DeepESConfig::has_async_es() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeepESConfig::set_has_async_es() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeepESConfig::clear_has_async_es() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeepESConfig::clear_async_es() {
  if (async_es_ != NULL) async_es_->::DeepES::AsyncESConfig::Clear();
  clear_has_async_es();
}
inline const ::DeepES::AsyncESConfig& DeepESConfig::async_es() const {
  return async_es_ != NULL ? *async_es_ : *default_instance_->async_es_;
}
inline ::DeepES::AsyncESConfig* DeepESConfig::mutable_async_es() {
  set_has_async_es();
  if (async_es_ == NULL) async_es_ = new ::DeepES::AsyncESConfig;
  return async_es_;
}
inline ::DeepES::AsyncESConfig* DeepESConfig::release_async_es() {
  clear_has_async_es();
  ::DeepES::AsyncESConfig* temp = async_es_;
  async_es_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GaussianSamplingConfig

// optional float std = 1 [default = 1];
inline bool GaussianSamplingConfig::has_std() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GaussianSamplingConfig::set_has_std() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GaussianSamplingConfig::clear_has_std() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GaussianSamplingConfig::clear_std() {
  std_ = 1;
  clear_has_std();
}
inline float GaussianSamplingConfig::std() const {
  return std_;
}
inline void GaussianSamplingConfig::set_std(float value) {
  set_has_std();
  std_ = value;
}

// -------------------------------------------------------------------

// OptimizerConfig

// optional string type = 1 [default = "SGD"];
inline bool OptimizerConfig::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OptimizerConfig::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OptimizerConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OptimizerConfig::clear_type() {
  if (type_ != &_default_type_) {
    type_->assign(_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& OptimizerConfig::type() const {
  return *type_;
}
inline void OptimizerConfig::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void OptimizerConfig::set_type(const char* value) {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void OptimizerConfig::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OptimizerConfig::mutable_type() {
  set_has_type();
  if (type_ == &_default_type_) {
    type_ = new ::std::string(_default_type_);
  }
  return type_;
}
inline ::std::string* OptimizerConfig::release_type() {
  clear_has_type();
  if (type_ == &_default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&_default_type_);
    return temp;
  }
}

// optional float base_lr = 2 [default = 0.001];
inline bool OptimizerConfig::has_base_lr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OptimizerConfig::set_has_base_lr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OptimizerConfig::clear_has_base_lr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OptimizerConfig::clear_base_lr() {
  base_lr_ = 0.001f;
  clear_has_base_lr();
}
inline float OptimizerConfig::base_lr() const {
  return base_lr_;
}
inline void OptimizerConfig::set_base_lr(float value) {
  set_has_base_lr();
  base_lr_ = value;
}

// optional float momentum = 3 [default = 0.9];
inline bool OptimizerConfig::has_momentum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OptimizerConfig::set_has_momentum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OptimizerConfig::clear_has_momentum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OptimizerConfig::clear_momentum() {
  momentum_ = 0.9f;
  clear_has_momentum();
}
inline float OptimizerConfig::momentum() const {
  return momentum_;
}
inline void OptimizerConfig::set_momentum(float value) {
  set_has_momentum();
  momentum_ = value;
}

// optional float beta1 = 4 [default = 0.9];
inline bool OptimizerConfig::has_beta1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OptimizerConfig::set_has_beta1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OptimizerConfig::clear_has_beta1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OptimizerConfig::clear_beta1() {
  beta1_ = 0.9f;
  clear_has_beta1();
}
inline float OptimizerConfig::beta1() const {
  return beta1_;
}
inline void OptimizerConfig::set_beta1(float value) {
  set_has_beta1();
  beta1_ = value;
}

// optional float beta2 = 5 [default = 0.999];
inline bool OptimizerConfig::has_beta2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OptimizerConfig::set_has_beta2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OptimizerConfig::clear_has_beta2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OptimizerConfig::clear_beta2() {
  beta2_ = 0.999f;
  clear_has_beta2();
}
inline float OptimizerConfig::beta2() const {
  return beta2_;
}
inline void OptimizerConfig::set_beta2(float value) {
  set_has_beta2();
  beta2_ = value;
}

// optional float epsilon = 6 [default = 1e-08];
inline bool OptimizerConfig::has_epsilon() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OptimizerConfig::set_has_epsilon() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OptimizerConfig::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OptimizerConfig::clear_epsilon() {
  epsilon_ = 1e-08f;
  clear_has_epsilon();
}
inline float OptimizerConfig::epsilon() const {
  return epsilon_;
}
inline void OptimizerConfig::set_epsilon(float value) {
  set_has_epsilon();
  epsilon_ = value;
}

// -------------------------------------------------------------------

// SamplingInfo

// repeated int32 key = 1;
inline int SamplingInfo::key_size() const {
  return key_.size();
}
inline void SamplingInfo::clear_key() {
  key_.Clear();
}
inline ::google::protobuf::int32 SamplingInfo::key(int index) const {
  return key_.Get(index);
}
inline void SamplingInfo::set_key(int index, ::google::protobuf::int32 value) {
  key_.Set(index, value);
}
inline void SamplingInfo::add_key(::google::protobuf::int32 value) {
  key_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SamplingInfo::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SamplingInfo::mutable_key() {
  return &key_;
}

// optional int32 model_iter_id = 2;
inline bool SamplingInfo::has_model_iter_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SamplingInfo::set_has_model_iter_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SamplingInfo::clear_has_model_iter_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SamplingInfo::clear_model_iter_id() {
  model_iter_id_ = 0;
  clear_has_model_iter_id();
}
inline ::google::protobuf::int32 SamplingInfo::model_iter_id() const {
  return model_iter_id_;
}
inline void SamplingInfo::set_model_iter_id(::google::protobuf::int32 value) {
  set_has_model_iter_id();
  model_iter_id_ = value;
}

// -------------------------------------------------------------------

// AsyncESConfig

// optional string model_warehouse = 1 [default = "./model_warehouse"];
inline bool AsyncESConfig::has_model_warehouse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AsyncESConfig::set_has_model_warehouse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AsyncESConfig::clear_has_model_warehouse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AsyncESConfig::clear_model_warehouse() {
  if (model_warehouse_ != &_default_model_warehouse_) {
    model_warehouse_->assign(_default_model_warehouse_);
  }
  clear_has_model_warehouse();
}
inline const ::std::string& AsyncESConfig::model_warehouse() const {
  return *model_warehouse_;
}
inline void AsyncESConfig::set_model_warehouse(const ::std::string& value) {
  set_has_model_warehouse();
  if (model_warehouse_ == &_default_model_warehouse_) {
    model_warehouse_ = new ::std::string;
  }
  model_warehouse_->assign(value);
}
inline void AsyncESConfig::set_model_warehouse(const char* value) {
  set_has_model_warehouse();
  if (model_warehouse_ == &_default_model_warehouse_) {
    model_warehouse_ = new ::std::string;
  }
  model_warehouse_->assign(value);
}
inline void AsyncESConfig::set_model_warehouse(const char* value, size_t size) {
  set_has_model_warehouse();
  if (model_warehouse_ == &_default_model_warehouse_) {
    model_warehouse_ = new ::std::string;
  }
  model_warehouse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AsyncESConfig::mutable_model_warehouse() {
  set_has_model_warehouse();
  if (model_warehouse_ == &_default_model_warehouse_) {
    model_warehouse_ = new ::std::string(_default_model_warehouse_);
  }
  return model_warehouse_;
}
inline ::std::string* AsyncESConfig::release_model_warehouse() {
  clear_has_model_warehouse();
  if (model_warehouse_ == &_default_model_warehouse_) {
    return NULL;
  } else {
    ::std::string* temp = model_warehouse_;
    model_warehouse_ = const_cast< ::std::string*>(&_default_model_warehouse_);
    return temp;
  }
}

// repeated string model_md5 = 2;
inline int AsyncESConfig::model_md5_size() const {
  return model_md5_.size();
}
inline void AsyncESConfig::clear_model_md5() {
  model_md5_.Clear();
}
inline const ::std::string& AsyncESConfig::model_md5(int index) const {
  return model_md5_.Get(index);
}
inline ::std::string* AsyncESConfig::mutable_model_md5(int index) {
  return model_md5_.Mutable(index);
}
inline void AsyncESConfig::set_model_md5(int index, const ::std::string& value) {
  model_md5_.Mutable(index)->assign(value);
}
inline void AsyncESConfig::set_model_md5(int index, const char* value) {
  model_md5_.Mutable(index)->assign(value);
}
inline void AsyncESConfig::set_model_md5(int index, const char* value, size_t size) {
  model_md5_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AsyncESConfig::add_model_md5() {
  return model_md5_.Add();
}
inline void AsyncESConfig::add_model_md5(const ::std::string& value) {
  model_md5_.Add()->assign(value);
}
inline void AsyncESConfig::add_model_md5(const char* value) {
  model_md5_.Add()->assign(value);
}
inline void AsyncESConfig::add_model_md5(const char* value, size_t size) {
  model_md5_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AsyncESConfig::model_md5() const {
  return model_md5_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AsyncESConfig::mutable_model_md5() {
  return &model_md5_;
}

// optional int32 max_to_keep = 3 [default = 5];
inline bool AsyncESConfig::has_max_to_keep() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AsyncESConfig::set_has_max_to_keep() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AsyncESConfig::clear_has_max_to_keep() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AsyncESConfig::clear_max_to_keep() {
  max_to_keep_ = 5;
  clear_has_max_to_keep();
}
inline ::google::protobuf::int32 AsyncESConfig::max_to_keep() const {
  return max_to_keep_;
}
inline void AsyncESConfig::set_max_to_keep(::google::protobuf::int32 value) {
  set_has_max_to_keep();
  max_to_keep_ = value;
}

// optional int32 model_iter_id = 4 [default = 0];
inline bool AsyncESConfig::has_model_iter_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AsyncESConfig::set_has_model_iter_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AsyncESConfig::clear_has_model_iter_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AsyncESConfig::clear_model_iter_id() {
  model_iter_id_ = 0;
  clear_has_model_iter_id();
}
inline ::google::protobuf::int32 AsyncESConfig::model_iter_id() const {
  return model_iter_id_;
}
inline void AsyncESConfig::set_model_iter_id(::google::protobuf::int32 value) {
  set_has_model_iter_id();
  model_iter_id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DeepES

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_deepes_2eproto__INCLUDED
